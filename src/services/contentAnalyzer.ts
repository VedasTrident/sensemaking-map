import { ProcessedDocument } from './documentProcessor';

export interface ExtractedNode {
  id: string;
  label: string;
  type: 'role' | 'project' | 'education' | 'goal' | 'interest' | 'skill';
  timeframe?: {
    start?: string;
    end?: string;
  };
  sourceDocuments: string[];
  connections: string[];
  position: { x: number; y: number };
  metadata: {
    confidence: number;
    autoGenerated: boolean;
    extractedText?: string;
  };
}

export interface AnalysisResult {
  nodes: ExtractedNode[];
  timeline: {
    startDate: string;
    endDate: string;
    events: Array<{
      date: string;
      nodeId: string;
      description: string;
    }>;
  };
}

export class ContentAnalyzer {
  private roleKeywords = [
    'software engineer', 'developer', 'analyst', 'consultant', 'manager', 
    'director', 'intern', 'associate', 'senior', 'lead', 'principal',
    'ceo', 'cto', 'founder', 'co-founder', 'vp', 'head of'
  ];

  private projectKeywords = [
    'project', 'built', 'developed', 'created', 'launched', 'implemented',
    'designed', 'worked on', 'contributed to', 'led', 'managed'
  ];

  private educationKeywords = [
    'university', 'college', 'school', 'degree', 'bachelor', 'master',
    'phd', 'graduate', 'undergraduate', 'mba', 'course', 'certification'
  ];

  private skillKeywords = [
    'javascript', 'python', 'react', 'node', 'sql', 'aws', 'docker',
    'kubernetes', 'git', 'agile', 'scrum', 'machine learning', 'ai'
  ];

  private goalKeywords = [
    'goal', 'want to', 'plan to', 'hope to', 'aspire', 'aim to',
    'future', 'next', 'planning', 'objective', 'target'
  ];

  async analyzeDocuments(documents: ProcessedDocument[]): Promise<AnalysisResult> {
    const nodes: ExtractedNode[] = [];
    const allEvents: Array<{ date: string; nodeId: string; description: string }> = [];

    for (const doc of documents) {
      const extractedNodes = await this.extractNodesFromDocument(doc);
      nodes.push(...extractedNodes);
      
      // Extract timeline events
      const events = this.extractTimelineEvents(doc, extractedNodes);
      allEvents.push(...events);
    }

    // Remove duplicates and merge similar nodes
    const mergedNodes = this.mergeSimilarNodes(nodes);
    
    // Establish connections between nodes
    const connectedNodes = this.establishConnections(mergedNodes);

    // Calculate positions for layout
    const positionedNodes = this.calculatePositions(connectedNodes);

    // Sort timeline events
    allEvents.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    const timeline = {
      startDate: allEvents.length > 0 ? allEvents[0].date : new Date().toISOString(),
      endDate: allEvents.length > 0 ? allEvents[allEvents.length - 1].date : new Date().toISOString(),
      events: allEvents
    };

    return {
      nodes: positionedNodes,
      timeline
    };
  }

  private async extractNodesFromDocument(doc: ProcessedDocument): Promise<ExtractedNode[]> {
    const nodes: ExtractedNode[] = [];
    const sentences = this.splitIntoSentences(doc.content);

    for (let i = 0; i < sentences.length; i++) {
      const sentence = sentences[i];
      const lowerSentence = sentence.toLowerCase();

      // Extract roles
      for (const keyword of this.roleKeywords) {
        if (lowerSentence.includes(keyword)) {
          const node = this.createNode({
            label: this.extractRoleLabel(sentence, keyword),
            type: 'role',
            sourceDoc: doc.fileName,
            extractedText: sentence,
            timeframe: this.extractTimeframe(sentence)
          });
          nodes.push(node);
        }
      }

      // Extract projects
      for (const keyword of this.projectKeywords) {
        if (lowerSentence.includes(keyword)) {
          const node = this.createNode({
            label: this.extractProjectLabel(sentence, keyword),
            type: 'project',
            sourceDoc: doc.fileName,
            extractedText: sentence,
            timeframe: this.extractTimeframe(sentence)
          });
          nodes.push(node);
        }
      }

      // Extract education
      for (const keyword of this.educationKeywords) {
        if (lowerSentence.includes(keyword)) {
          const node = this.createNode({
            label: this.extractEducationLabel(sentence, keyword),
            type: 'education',
            sourceDoc: doc.fileName,
            extractedText: sentence,
            timeframe: this.extractTimeframe(sentence)
          });
          nodes.push(node);
        }
      }

      // Extract skills
      for (const keyword of this.skillKeywords) {
        if (lowerSentence.includes(keyword)) {
          const node = this.createNode({
            label: keyword.charAt(0).toUpperCase() + keyword.slice(1),
            type: 'skill',
            sourceDoc: doc.fileName,
            extractedText: sentence
          });
          nodes.push(node);
        }
      }

      // Extract goals
      for (const keyword of this.goalKeywords) {
        if (lowerSentence.includes(keyword)) {
          const node = this.createNode({
            label: this.extractGoalLabel(sentence, keyword),
            type: 'goal',
            sourceDoc: doc.fileName,
            extractedText: sentence
          });
          nodes.push(node);
        }
      }
    }

    return nodes;
  }

  private splitIntoSentences(text: string): string[] {
    return text
      .split(/[.!?]+/)
      .map(s => s.trim())
      .filter(s => s.length > 10); // Filter out very short sentences
  }

  private createNode(params: {
    label: string;
    type: ExtractedNode['type'];
    sourceDoc: string;
    extractedText: string;
    timeframe?: { start?: string; end?: string };
  }): ExtractedNode {
    return {
      id: `node_${Math.random().toString(36).substring(7)}`,
      label: params.label,
      type: params.type,
      timeframe: params.timeframe,
      sourceDocuments: [params.sourceDoc],
      connections: [],
      position: { x: 0, y: 0 }, // Will be calculated later
      metadata: {
        confidence: 0.8,
        autoGenerated: true,
        extractedText: params.extractedText
      }
    };
  }

  private extractRoleLabel(sentence: string, keyword: string): string {
    // Try to extract a clean role title from the sentence
    const words = sentence.split(' ');
    const keywordIndex = words.findIndex(word => 
      word.toLowerCase().includes(keyword.toLowerCase())
    );
    
    if (keywordIndex !== -1) {
      // Take a few words around the keyword to form the role title
      const start = Math.max(0, keywordIndex - 2);
      const end = Math.min(words.length, keywordIndex + 3);
      return words.slice(start, end).join(' ').replace(/[^a-zA-Z0-9\s]/g, '').trim();
    }
    
    return keyword.charAt(0).toUpperCase() + keyword.slice(1);
  }

  private extractProjectLabel(sentence: string, keyword: string): string {
    // Extract project name or description
    const afterKeyword = sentence.toLowerCase().split(keyword.toLowerCase())[1];
    if (afterKeyword) {
      const words = afterKeyword.trim().split(' ').slice(0, 5);
      return words.join(' ').replace(/[^a-zA-Z0-9\s]/g, '').trim() || 'Project';
    }
    return 'Project';
  }

  private extractEducationLabel(sentence: string, keyword: string): string {
    // Extract educational institution or degree
    if (keyword === 'degree' || keyword === 'bachelor' || keyword === 'master') {
      return sentence.substring(0, 50).replace(/[^a-zA-Z0-9\s]/g, '').trim();
    }
    
    const words = sentence.split(' ');
    const keywordIndex = words.findIndex(word => 
      word.toLowerCase().includes(keyword.toLowerCase())
    );
    
    if (keywordIndex !== -1) {
      const start = Math.max(0, keywordIndex - 1);
      const end = Math.min(words.length, keywordIndex + 3);
      return words.slice(start, end).join(' ').replace(/[^a-zA-Z0-9\s]/g, '').trim();
    }
    
    return keyword.charAt(0).toUpperCase() + keyword.slice(1);
  }

  private extractGoalLabel(sentence: string, keyword: string): string {
    // Extract future goal or aspiration
    const afterKeyword = sentence.toLowerCase().split(keyword.toLowerCase())[1];
    if (afterKeyword) {
      const words = afterKeyword.trim().split(' ').slice(0, 8);
      return words.join(' ').replace(/[^a-zA-Z0-9\s]/g, '').trim() || 'Future Goal';
    }
    return 'Future Goal';
  }

  private extractTimeframe(sentence: string): { start?: string; end?: string } | undefined {
    // Simple date extraction - could be enhanced with more sophisticated NLP
    const yearMatches = sentence.match(/\b(19|20)\d{2}\b/g);
    const monthYearMatches = sentence.match(/\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(19|20)\d{2}\b/gi);
    
    if (monthYearMatches && monthYearMatches.length > 0) {
      const dates = monthYearMatches.map(date => new Date(date).toISOString().substring(0, 7));
      return {
        start: dates[0],
        end: dates.length > 1 ? dates[dates.length - 1] : undefined
      };
    }
    
    if (yearMatches && yearMatches.length > 0) {
      return {
        start: `${yearMatches[0]}-01`,
        end: yearMatches.length > 1 ? `${yearMatches[yearMatches.length - 1]}-12` : undefined
      };
    }
    
    return undefined;
  }

  private mergeSimilarNodes(nodes: ExtractedNode[]): ExtractedNode[] {
    // Simple deduplication based on label similarity
    const merged: ExtractedNode[] = [];
    
    for (const node of nodes) {
      const similar = merged.find(m => 
        m.type === node.type && 
        this.calculateSimilarity(m.label, node.label) > 0.7
      );
      
      if (similar) {
        // Merge nodes
        similar.sourceDocuments = [...new Set([...similar.sourceDocuments, ...node.sourceDocuments])];
        if (node.timeframe && !similar.timeframe) {
          similar.timeframe = node.timeframe;
        }
      } else {
        merged.push(node);
      }
    }
    
    return merged;
  }

  private calculateSimilarity(str1: string, str2: string): number {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const distance = this.levenshteinDistance(longer, shorter);
    return (longer.length - distance) / longer.length;
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  private establishConnections(nodes: ExtractedNode[]): ExtractedNode[] {
    // Establish connections based on time proximity and content similarity
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const node1 = nodes[i];
        const node2 = nodes[j];
        
        // Connect nodes from the same document
        if (node1.sourceDocuments.some(doc => node2.sourceDocuments.includes(doc))) {
          if (!node1.connections.includes(node2.id)) {
            node1.connections.push(node2.id);
          }
          if (!node2.connections.includes(node1.id)) {
            node2.connections.push(node1.id);
          }
        }
        
        // Connect nodes with overlapping timeframes
        if (node1.timeframe && node2.timeframe) {
          const overlap = this.checkTimeframeOverlap(node1.timeframe, node2.timeframe);
          if (overlap && !node1.connections.includes(node2.id)) {
            node1.connections.push(node2.id);
            node2.connections.push(node1.id);
          }
        }
      }
    }
    
    return nodes;
  }

  private checkTimeframeOverlap(
    timeframe1: { start?: string; end?: string },
    timeframe2: { start?: string; end?: string }
  ): boolean {
    if (!timeframe1.start || !timeframe2.start) return false;
    
    const start1 = new Date(timeframe1.start);
    const end1 = timeframe1.end ? new Date(timeframe1.end) : new Date();
    const start2 = new Date(timeframe2.start);
    const end2 = timeframe2.end ? new Date(timeframe2.end) : new Date();
    
    return start1 <= end2 && start2 <= end1;
  }

  private calculatePositions(nodes: ExtractedNode[]): ExtractedNode[] {
    // Simple force-directed layout
    const width = 800;
    const height = 600;
    
    // Group nodes by type for better organization
    const nodesByType = nodes.reduce((acc, node) => {
      if (!acc[node.type]) acc[node.type] = [];
      acc[node.type].push(node);
      return acc;
    }, {} as Record<string, ExtractedNode[]>);
    
    let yOffset = 50;
    const typeSpacing = height / Object.keys(nodesByType).length;
    
    Object.entries(nodesByType).forEach(([type, typeNodes], typeIndex) => {
      const xSpacing = width / (typeNodes.length + 1);
      
      typeNodes.forEach((node, index) => {
        node.position = {
          x: xSpacing * (index + 1),
          y: typeIndex * typeSpacing + 100
        };
      });
    });
    
    return nodes;
  }

  private extractTimelineEvents(
    doc: ProcessedDocument,
    nodes: ExtractedNode[]
  ): Array<{ date: string; nodeId: string; description: string }> {
    const events: Array<{ date: string; nodeId: string; description: string }> = [];
    
    for (const node of nodes) {
      if (node.timeframe?.start) {
        events.push({
          date: node.timeframe.start,
          nodeId: node.id,
          description: `${node.type}: ${node.label}`
        });
      }
    }
    
    return events;
  }
}