import { ProcessedDocument } from './documentProcessor';

export interface ExtractedNode {
  id: string;
  label: string;
  type: 'role' | 'project' | 'education' | 'goal' | 'interest' | 'skill';
  timeframe?: {
    start?: string;
    end?: string;
  };
  sourceDocuments: string[];
  connections: string[];
  position: { x: number; y: number };
  metadata: {
    confidence: number;
    autoGenerated: boolean;
    extractedText?: string;
    context?: string;
  };
}

export interface AnalysisResult {
  nodes: ExtractedNode[];
  timeline: {
    startDate: string;
    endDate: string;
    events: Array<{
      date: string;
      nodeId: string;
      description: string;
    }>;
  };
}

export class SimpleContentAnalyzer {
  async analyzeDocuments(documents: ProcessedDocument[]): Promise<AnalysisResult> {
    console.log('\n=== STARTING SIMPLE ANALYSIS ===');
    
    const allNodes: ExtractedNode[] = [];
    const allEvents: Array<{ date: string; nodeId: string; description: string }> = [];

    for (const doc of documents) {
      console.log(`\nAnalyzing: ${doc.fileName}`);
      console.log(`Content length: ${doc.content.length} characters`);
      console.log(`First 200 chars: "${doc.content.substring(0, 200)}..."`);
      
      // Skip if document processing failed
      if (doc.content.includes('[PDF file:') || doc.content.includes('Could not extract')) {
        console.log('Skipping failed document:', doc.fileName);
        continue;
      }
      
      const nodes = this.extractSimpleNodes(doc);
      console.log(`Extracted ${nodes.length} nodes from ${doc.fileName}`);
      allNodes.push(...nodes);
    }

    // Clean up nodes
    const cleanedNodes = this.removeDuplicatesAndNoise(allNodes);
    console.log(`After cleanup: ${cleanedNodes.length} nodes`);
    
    // Add connections
    const connectedNodes = this.addSimpleConnections(cleanedNodes);
    
    // Position nodes
    const positionedNodes = this.positionNodes(connectedNodes);

    // Create timeline from nodes
    for (const node of positionedNodes) {
      if (node.timeframe?.start) {
        allEvents.push({
          date: node.timeframe.start,
          nodeId: node.id,
          description: `${node.type}: ${node.label}`
        });
      }
    }

    allEvents.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    const result = {
      nodes: positionedNodes,
      timeline: {
        startDate: allEvents.length > 0 ? allEvents[0].date : new Date().toISOString(),
        endDate: allEvents.length > 0 ? allEvents[allEvents.length - 1].date : new Date().toISOString(),
        events: allEvents
      }
    };

    console.log('\n=== ANALYSIS COMPLETE ===');
    console.log(`Final result: ${result.nodes.length} nodes, ${result.timeline.events.length} events`);
    
    return result;
  }

  private extractSimpleNodes(doc: ProcessedDocument): ExtractedNode[] {
    const nodes: ExtractedNode[] = [];
    const lines = doc.content.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    console.log(`Processing ${lines.length} lines from ${doc.fileName}`);
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
      
      // Look for clear role patterns - be very specific
      const roleNode = this.tryExtractRole(line, nextLine, doc.fileName);
      if (roleNode) {
        console.log(`Found role: "${roleNode.label}"`);
        nodes.push(roleNode);
        continue;
      }
      
      // Look for education patterns
      const eduNode = this.tryExtractEducation(line, doc.fileName);
      if (eduNode) {
        console.log(`Found education: "${eduNode.label}"`);
        nodes.push(eduNode);
        continue;
      }
      
      // Look for project patterns (bullet points with clear actions)
      const projectNode = this.tryExtractProject(line, doc.fileName);
      if (projectNode) {
        console.log(`Found project: "${projectNode.label}"`);
        nodes.push(projectNode);
      }
    }
    
    // Only extract skills from obvious skills sections
    const skillNodes = this.extractSkillsFromSection(doc);
    nodes.push(...skillNodes);
    
    return nodes;
  }

  private tryExtractRole(line: string, nextLine: string, fileName: string): ExtractedNode | null {
    // Very specific patterns for job titles
    const patterns = [
      // "Software Engineer at Google"
      /^(.+?)\s+at\s+(.+?)(?:\s*\(|\s*$|\s*-)/i,
      // "Product Manager | Meta" 
      /^(.+?)\s*\|\s*(.+?)(?:\s*\(|\s*$)/i,
      // "Senior Consultant, McKinsey & Company"
      /^(.+?),\s+(.+?)(?:\s*\(|\s*$)/i
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        const title = match[1].trim();
        const company = match[2].trim();
        
        // Validate this looks like a real job title
        if (this.looksLikeJobTitle(title) && this.looksLikeCompany(company)) {
          const timeframe = this.extractDates(line + ' ' + nextLine);
          
          return {
            id: `role_${Date.now()}_${Math.random().toString(36).substring(7)}`,
            label: `${title} at ${company}`,
            type: 'role',
            timeframe,
            sourceDocuments: [fileName],
            connections: [],
            position: { x: 0, y: 0 },
            metadata: {
              confidence: 0.9,
              autoGenerated: true,
              extractedText: line,
              context: 'role'
            }
          };
        }
      }
    }
    
    return null;
  }

  private tryExtractEducation(line: string, fileName: string): ExtractedNode | null {
    // Look for clear education patterns
    const eduPatterns = [
      // "Bachelor of Science, MIT"
      /(?:bachelor|master|phd|mba|degree)\s+(?:of\s+|in\s+)?(.+?)(?:,\s*(.+?))?(?:\s*\(|\s*$)/i,
      // "MIT - Computer Science"
      /^(.+?)\s*[-–]\s*(.+?)(?:\s*\(|\s*$)/i,
      // "University of Cambridge (2013-2017)"
      /^(.+?university|.+?college|.+?school|.+?institute)(?:\s*\(|\s*$)/i
    ];

    for (const pattern of eduPatterns) {
      const match = line.match(pattern);
      if (match) {
        let label = '';
        
        if (match[1] && match[2]) {
          // Format: "Degree, Institution" or "Institution - Program"
          label = `${match[1].trim()} at ${match[2].trim()}`;
        } else if (match[1]) {
          label = match[1].trim();
        }
        
        if (label.length > 5 && this.looksLikeEducation(label)) {
          const timeframe = this.extractDates(line);
          
          return {
            id: `edu_${Date.now()}_${Math.random().toString(36).substring(7)}`,
            label,
            type: 'education',
            timeframe,
            sourceDocuments: [fileName],
            connections: [],
            position: { x: 0, y: 0 },
            metadata: {
              confidence: 0.8,
              autoGenerated: true,
              extractedText: line,
              context: 'education'
            }
          };
        }
      }
    }
    
    return null;
  }

  private tryExtractProject(line: string, fileName: string): ExtractedNode | null {
    // Only extract from bullet points with clear action verbs
    const bulletMatch = line.match(/^[•\-*]\s*(.+)/);
    if (!bulletMatch) return null;
    
    const projectText = bulletMatch[1].trim();
    
    // Must contain clear action verbs and be substantial
    const actionVerbs = ['built', 'created', 'developed', 'designed', 'launched', 'implemented', 'led', 'managed'];
    const hasAction = actionVerbs.some(verb => projectText.toLowerCase().includes(verb));
    
    if (hasAction && projectText.length > 30 && projectText.length < 100) {
      return {
        id: `project_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: projectText,
        type: 'project',
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.7,
          autoGenerated: true,
          extractedText: line,
          context: 'project'
        }
      };
    }
    
    return null;
  }

  private extractSkillsFromSection(doc: ProcessedDocument): ExtractedNode[] {
    const skillNodes: ExtractedNode[] = [];
    const content = doc.content.toLowerCase();
    
    // Only if there's a clear skills section
    if (!content.includes('skills') && !content.includes('technical')) {
      return skillNodes;
    }
    
    // Find the skills section
    const lines = doc.content.split('\n');
    let inSkillsSection = false;
    
    for (const line of lines) {
      const lowerLine = line.toLowerCase().trim();
      
      // Start of skills section
      if (lowerLine.includes('skills') || lowerLine.includes('technical')) {
        inSkillsSection = true;
        continue;
      }
      
      // End of skills section (next major section)
      if (inSkillsSection && lowerLine.match(/^(experience|education|projects|about)/)) {
        break;
      }
      
      if (inSkillsSection && line.trim().length > 0) {
        // Extract skills from this line
        const skillCategories = this.extractSkillsFromLine(line, doc.fileName);
        skillNodes.push(...skillCategories);
      }
    }
    
    return skillNodes;
  }

  private extractSkillsFromLine(line: string, fileName: string): ExtractedNode[] {
    const skills: ExtractedNode[] = [];
    
    // Look for category patterns like "Programming: Python, JavaScript"
    const categoryMatch = line.match(/^(.+?):\s*(.+)/);
    if (categoryMatch) {
      const category = categoryMatch[1].trim();
      const skillList = categoryMatch[2].trim();
      
      if (category.length < 30 && skillList.length > 5) {
        skills.push({
          id: `skill_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          label: category,
          type: 'skill',
          sourceDocuments: [fileName],
          connections: [],
          position: { x: 0, y: 0 },
          metadata: {
            confidence: 0.8,
            autoGenerated: true,
            extractedText: line,
            context: 'skill'
          }
        });
      }
    }
    
    return skills;
  }

  private extractDates(text: string): { start?: string; end?: string } | undefined {
    // Simple date patterns
    const patterns = [
      /(\d{4})\s*[-–]\s*(\d{4})/,  // 2020-2023
      /(\d{4})\s*[-–]\s*(present|current)/i,  // 2020-Present
      /\((\d{4})\s*[-–]\s*(\d{4})\)/,  // (2020-2023)
      /\b(\d{4})\b/  // Just a year
    ];
    
    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        if (match[2] && match[2].toLowerCase().includes('present')) {
          return { start: `${match[1]}-01` };
        } else if (match[2] && match[1] !== match[2]) {
          return { start: `${match[1]}-01`, end: `${match[2]}-12` };
        } else if (match[1]) {
          return { start: `${match[1]}-01` };
        }
      }
    }
    
    return undefined;
  }

  private looksLikeJobTitle(title: string): boolean {
    // Very conservative - only obvious job titles
    const jobWords = [
      'engineer', 'developer', 'manager', 'analyst', 'consultant', 'director',
      'specialist', 'coordinator', 'lead', 'senior', 'junior', 'associate',
      'product', 'software', 'data', 'marketing', 'sales', 'finance'
    ];
    
    const lowerTitle = title.toLowerCase();
    return jobWords.some(word => lowerTitle.includes(word)) && 
           title.length > 3 && title.length < 50 &&
           !lowerTitle.includes('@') && !lowerTitle.includes('http');
  }

  private looksLikeCompany(company: string): boolean {
    return company.length > 1 && company.length < 50 && 
           !company.toLowerCase().includes('@') &&
           !company.toLowerCase().includes('http') &&
           company !== 'present' && company !== 'current';
  }

  private looksLikeEducation(text: string): boolean {
    const eduWords = ['university', 'college', 'school', 'institute', 'academy', 'bachelor', 'master', 'phd', 'mba'];
    const lowerText = text.toLowerCase();
    return eduWords.some(word => lowerText.includes(word));
  }

  private removeDuplicatesAndNoise(nodes: ExtractedNode[]): ExtractedNode[] {
    const seen = new Set<string>();
    const cleaned: ExtractedNode[] = [];
    
    for (const node of nodes) {
      const key = `${node.type}:${node.label.toLowerCase()}`;
      
      if (!seen.has(key) && node.label.length > 2) {
        seen.add(key);
        cleaned.push(node);
      }
    }
    
    return cleaned;
  }

  private addSimpleConnections(nodes: ExtractedNode[]): ExtractedNode[] {
    // Very simple: connect nodes from the same document
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const node1 = nodes[i];
        const node2 = nodes[j];
        
        if (node1.sourceDocuments.some(doc => node2.sourceDocuments.includes(doc))) {
          if (!node1.connections.includes(node2.id)) {
            node1.connections.push(node2.id);
          }
          if (!node2.connections.includes(node1.id)) {
            node2.connections.push(node1.id);
          }
        }
      }
    }
    
    return nodes;
  }

  private positionNodes(nodes: ExtractedNode[]): ExtractedNode[] {
    const width = 1000;
    const height = 600;
    
    // Group by type
    const byType = nodes.reduce((acc, node) => {
      if (!acc[node.type]) acc[node.type] = [];
      acc[node.type].push(node);
      return acc;
    }, {} as Record<string, ExtractedNode[]>);
    
    const types = ['education', 'role', 'project', 'skill', 'goal', 'interest'];
    const usedTypes = types.filter(type => byType[type]?.length > 0);
    
    usedTypes.forEach((type, typeIndex) => {
      const typeNodes = byType[type];
      const y = (height / usedTypes.length) * typeIndex + 100;
      const xSpacing = width / (typeNodes.length + 1);
      
      typeNodes.forEach((node, index) => {
        node.position = {
          x: xSpacing * (index + 1),
          y: y
        };
      });
    });
    
    return nodes;
  }
}