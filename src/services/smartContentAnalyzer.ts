import { ProcessedDocument } from './documentProcessor';

export interface ExtractedNode {
  id: string;
  label: string;
  type: 'role' | 'project' | 'education' | 'goal' | 'interest' | 'skill';
  timeframe?: {
    start?: string;
    end?: string;
  };
  sourceDocuments: string[];
  connections: string[];
  position: { x: number; y: number };
  metadata: {
    confidence: number;
    autoGenerated: boolean;
    extractedText?: string;
    context?: string;
  };
}

export interface AnalysisResult {
  nodes: ExtractedNode[];
  timeline: {
    startDate: string;
    endDate: string;
    events: Array<{
      date: string;
      nodeId: string;
      description: string;
    }>;
  };
}

export class SmartContentAnalyzer {
  async analyzeDocuments(documents: ProcessedDocument[]): Promise<AnalysisResult> {
    const allNodes: ExtractedNode[] = [];
    const allEvents: Array<{ date: string; nodeId: string; description: string }> = [];

    for (const doc of documents) {
      console.log(`Analyzing document: ${doc.fileName}`);
      console.log(`Content preview: ${doc.content.substring(0, 500)}...`);
      
      const nodes = await this.extractSmartNodes(doc);
      console.log(`Extracted ${nodes.length} nodes from ${doc.fileName}`);
      
      allNodes.push(...nodes);
      
      // Extract timeline events from nodes
      for (const node of nodes) {
        if (node.timeframe?.start) {
          allEvents.push({
            date: node.timeframe.start,
            nodeId: node.id,
            description: `${node.type}: ${node.label}`
          });
        }
      }
    }

    // Clean and deduplicate nodes
    const cleanedNodes = this.cleanAndDeduplicateNodes(allNodes);
    
    // Add connections between related nodes
    const connectedNodes = this.addConnections(cleanedNodes);
    
    // Position nodes for visualization
    const positionedNodes = this.calculatePositions(connectedNodes);

    // Sort timeline events
    allEvents.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    const timeline = {
      startDate: allEvents.length > 0 ? allEvents[0].date : new Date().toISOString(),
      endDate: allEvents.length > 0 ? allEvents[allEvents.length - 1].date : new Date().toISOString(),
      events: allEvents
    };

    console.log(`Final analysis: ${positionedNodes.length} nodes, ${allEvents.length} timeline events`);
    
    return {
      nodes: positionedNodes,
      timeline
    };
  }

  private async extractSmartNodes(doc: ProcessedDocument): Promise<ExtractedNode[]> {
    const nodes: ExtractedNode[] = [];
    
    // Split content into meaningful sections
    const sections = this.splitIntoSections(doc.content);
    
    for (const section of sections) {
      // Extract roles with better context awareness
      const roles = this.extractRoles(section, doc.fileName);
      nodes.push(...roles);
      
      // Extract education with context
      const education = this.extractEducation(section, doc.fileName);
      nodes.push(...education);
      
      // Extract projects with context  
      const projects = this.extractProjects(section, doc.fileName);
      nodes.push(...projects);
      
      // Extract skills meaningfully
      const skills = this.extractSkills(section, doc.fileName);
      nodes.push(...skills);
      
      // Extract goals
      const goals = this.extractGoals(section, doc.fileName);
      nodes.push(...goals);
    }

    return nodes.filter(node => node.label.length > 2 && !this.isGenericNoise(node.label));
  }

  private splitIntoSections(content: string): Array<{ text: string; context: string }> {
    const sections: Array<{ text: string; context: string }> = [];
    
    // Split by common section headers
    const sectionHeaders = [
      'experience', 'work experience', 'employment', 'career',
      'education', 'academic', 'qualifications',
      'skills', 'technical skills', 'competencies',
      'projects', 'achievements', 'accomplishments',
      'summary', 'profile', 'about'
    ];
    
    const lines = content.split('\n');
    let currentSection = { text: '', context: 'general' };
    
    for (const line of lines) {
      const lowerLine = line.toLowerCase().trim();
      
      // Check if this line is a section header
      const matchedHeader = sectionHeaders.find(header => 
        lowerLine.includes(header) && lowerLine.length < 50
      );
      
      if (matchedHeader) {
        // Save previous section if it has content
        if (currentSection.text.trim().length > 50) {
          sections.push({ ...currentSection });
        }
        // Start new section
        currentSection = { text: line + '\n', context: matchedHeader };
      } else {
        currentSection.text += line + '\n';
      }
    }
    
    // Add final section
    if (currentSection.text.trim().length > 50) {
      sections.push(currentSection);
    }
    
    // If no clear sections found, treat as one section
    if (sections.length === 0) {
      sections.push({ text: content, context: 'general' });
    }
    
    return sections;
  }

  private extractRoles(section: { text: string; context: string }, fileName: string): ExtractedNode[] {
    const roles: ExtractedNode[] = [];
    const lines = section.text.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const nextLine = i < lines.length - 1 ? lines[i + 1].trim() : '';
      
      // Look for job title patterns
      const jobTitlePatterns = [
        /^(.+?)\s+at\s+(.+?)(?:\s*\(|\s*-|\s*•|\s*$)/i,
        /^(.+?)\s*-\s*(.+?)(?:\s*\(|\s*$)/i,
        /^(.+?),\s*(.+?)(?:\s*\(|\s*$)/i
      ];
      
      for (const pattern of jobTitlePatterns) {
        const match = line.match(pattern);
        if (match && match[1] && match[2]) {
          const title = match[1].trim();
          const company = match[2].trim();
          
          // Filter out noise
          if (this.isValidJobTitle(title) && this.isValidCompany(company)) {
            const timeframe = this.extractTimeframe(line + ' ' + nextLine);
            
            roles.push({
              id: `role_${Math.random().toString(36).substring(7)}`,
              label: `${title} at ${company}`,
              type: 'role',
              timeframe,
              sourceDocuments: [fileName],
              connections: [],
              position: { x: 0, y: 0 },
              metadata: {
                confidence: 0.9,
                autoGenerated: true,
                extractedText: line,
                context: section.context
              }
            });
          }
        }
      }
    }
    
    return roles;
  }

  private extractEducation(section: { text: string; context: string }, fileName: string): ExtractedNode[] {
    const education: ExtractedNode[] = [];
    const lines = section.text.split('\n');
    
    const degreePatterns = [
      /(?:bachelor|master|phd|doctorate|diploma|certificate|degree)\s+(?:of|in|from)?\s*(.+?)(?:\s+at\s+|\s+from\s+|\s+-\s+)(.+?)(?:\s*\(|\s*-|\s*$)/i,
      /(.+?)\s+(?:university|college|school|institute|academy)\s*(?:\(|\s*-|\s*$)/i
    ];
    
    for (const line of lines) {
      for (const pattern of degreePatterns) {
        const match = line.match(pattern);
        if (match) {
          const program = match[1]?.trim();
          const institution = match[2]?.trim() || match[1]?.trim();
          
          if (program && institution && program.length > 2) {
            const timeframe = this.extractTimeframe(line);
            
            education.push({
              id: `edu_${Math.random().toString(36).substring(7)}`,
              label: institution.includes('university') || institution.includes('college') 
                ? `${program} at ${institution}`
                : institution,
              type: 'education',
              timeframe,
              sourceDocuments: [fileName],
              connections: [],
              position: { x: 0, y: 0 },
              metadata: {
                confidence: 0.85,
                autoGenerated: true,
                extractedText: line,
                context: section.context
              }
            });
          }
        }
      }
    }
    
    return education;
  }

  private extractProjects(section: { text: string; context: string }, fileName: string): ExtractedNode[] {
    const projects: ExtractedNode[] = [];
    const lines = section.text.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Look for bullet points or project descriptions
      if (trimmedLine.match(/^[•\-*]\s*(.+)/)) {
        const projectText = trimmedLine.replace(/^[•\-*]\s*/, '');
        
        // Look for action verbs that indicate projects
        const actionVerbs = [
          'built', 'created', 'developed', 'designed', 'implemented', 'launched',
          'led', 'managed', 'coordinated', 'established', 'delivered', 'achieved'
        ];
        
        const hasActionVerb = actionVerbs.some(verb => 
          projectText.toLowerCase().includes(verb)
        );
        
        if (hasActionVerb && projectText.length > 20 && projectText.length < 150) {
          projects.push({
            id: `project_${Math.random().toString(36).substring(7)}`,
            label: projectText.length > 60 
              ? projectText.substring(0, 60) + '...'
              : projectText,
            type: 'project',
            sourceDocuments: [fileName],
            connections: [],
            position: { x: 0, y: 0 },
            metadata: {
              confidence: 0.75,
              autoGenerated: true,
              extractedText: trimmedLine,
              context: section.context
            }
          });
        }
      }
    }
    
    return projects;
  }

  private extractSkills(section: { text: string; context: string }, fileName: string): ExtractedNode[] {
    const skills: ExtractedNode[] = [];
    
    // Only extract skills from relevant sections
    if (!section.context.includes('skill') && !section.context.includes('technical')) {
      return skills;
    }
    
    const skillCategories = {
      'Programming Languages': ['javascript', 'python', 'java', 'typescript', 'c++', 'c#', 'go', 'rust', 'php', 'ruby'],
      'Frameworks & Libraries': ['react', 'angular', 'vue', 'node', 'express', 'django', 'flask', 'spring', 'laravel'],
      'Databases': ['mysql', 'postgresql', 'mongodb', 'redis', 'elasticsearch', 'sqlite', 'oracle'],
      'Cloud & DevOps': ['aws', 'azure', 'gcp', 'docker', 'kubernetes', 'jenkins', 'git', 'terraform'],
      'Data & Analytics': ['sql', 'tableau', 'powerbi', 'excel', 'r', 'matlab', 'spark', 'hadoop']
    };
    
    const text = section.text.toLowerCase();
    
    for (const [category, skillList] of Object.entries(skillCategories)) {
      const foundSkills = skillList.filter(skill => 
        text.includes(skill.toLowerCase())
      );
      
      if (foundSkills.length > 0) {
        skills.push({
          id: `skill_${Math.random().toString(36).substring(7)}`,
          label: category,
          type: 'skill',
          sourceDocuments: [fileName],
          connections: [],
          position: { x: 0, y: 0 },
          metadata: {
            confidence: 0.8,
            autoGenerated: true,
            extractedText: foundSkills.join(', '),
            context: section.context
          }
        });
      }
    }
    
    return skills;
  }

  private extractGoals(section: { text: string; context: string }, fileName: string): ExtractedNode[] {
    const goals: ExtractedNode[] = [];
    const lines = section.text.split('\n');
    
    const goalPhrases = [
      'want to', 'plan to', 'hope to', 'aspire to', 'aim to', 'goal is to',
      'seeking to', 'looking to', 'interested in', 'passionate about'
    ];
    
    for (const line of lines) {
      const lowerLine = line.toLowerCase();
      
      for (const phrase of goalPhrases) {
        if (lowerLine.includes(phrase)) {
          const goalText = line.trim();
          
          if (goalText.length > 20 && goalText.length < 120) {
            goals.push({
              id: `goal_${Math.random().toString(36).substring(7)}`,
              label: goalText.length > 60 
                ? goalText.substring(0, 60) + '...'
                : goalText,
              type: 'goal',
              sourceDocuments: [fileName],
              connections: [],
              position: { x: 0, y: 0 },
              metadata: {
                confidence: 0.7,
                autoGenerated: true,
                extractedText: line,
                context: section.context
              }
            });
          }
          break;
        }
      }
    }
    
    return goals;
  }

  private extractTimeframe(text: string): { start?: string; end?: string } | undefined {
    // Enhanced date extraction patterns
    const patterns = [
      // 2020 - 2023, 2020-2023
      /(\d{4})\s*[-–]\s*(\d{4})/,
      // Jan 2020 - Dec 2023
      /(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})\s*[-–]\s*(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+(\d{4})/i,
      // 2020 - Present
      /(\d{4})\s*[-–]\s*(present|current|now)/i,
      // Single year
      /\b(\d{4})\b/
    ];
    
    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        if (pattern.source.includes('present|current|now')) {
          return {
            start: `${match[1]}-01`,
            end: undefined
          };
        } else if (match[2] && match[1] !== match[2]) {
          return {
            start: `${match[1]}-01`,
            end: `${match[2]}-12`
          };
        } else if (match[4]) {
          return {
            start: `${match[2]}-01`,
            end: `${match[4]}-12`
          };
        } else {
          return {
            start: `${match[1]}-01`
          };
        }
      }
    }
    
    return undefined;
  }

  private isValidJobTitle(title: string): boolean {
    const invalidTitles = ['email', 'phone', 'address', 'linkedin', 'github', 'website'];
    return title.length > 2 && title.length < 50 && 
           !invalidTitles.some(invalid => title.toLowerCase().includes(invalid));
  }

  private isValidCompany(company: string): boolean {
    return company.length > 1 && company.length < 50 && 
           !company.toLowerCase().includes('@');
  }

  private isGenericNoise(label: string): boolean {
    const noiseWords = [
      'and', 'or', 'the', 'a', 'an', 'of', 'in', 'on', 'at', 'to', 'for',
      'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'be', 'been',
      'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should'
    ];
    
    return noiseWords.includes(label.toLowerCase()) || 
           label.length < 3 || 
           /^\d+$/.test(label) ||
           label.toLowerCase().includes('lorem ipsum');
  }

  private cleanAndDeduplicateNodes(nodes: ExtractedNode[]): ExtractedNode[] {
    const uniqueNodes: ExtractedNode[] = [];
    const seenLabels = new Set<string>();
    
    for (const node of nodes) {
      const normalizedLabel = node.label.toLowerCase().trim();
      
      if (!seenLabels.has(normalizedLabel) && !this.isGenericNoise(node.label)) {
        seenLabels.add(normalizedLabel);
        uniqueNodes.push(node);
      }
    }
    
    return uniqueNodes;
  }

  private addConnections(nodes: ExtractedNode[]): ExtractedNode[] {
    // Add simple connections based on co-occurrence in same document
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const node1 = nodes[i];
        const node2 = nodes[j];
        
        // Connect nodes from the same document
        if (node1.sourceDocuments.some(doc => node2.sourceDocuments.includes(doc))) {
          if (!node1.connections.includes(node2.id)) {
            node1.connections.push(node2.id);
          }
          if (!node2.connections.includes(node1.id)) {
            node2.connections.push(node1.id);
          }
        }
      }
    }
    
    return nodes;
  }

  private calculatePositions(nodes: ExtractedNode[]): ExtractedNode[] {
    const width = 1000;
    const height = 600;
    
    // Group nodes by type
    const nodesByType = nodes.reduce((acc, node) => {
      if (!acc[node.type]) acc[node.type] = [];
      acc[node.type].push(node);
      return acc;
    }, {} as Record<string, ExtractedNode[]>);
    
    const typeOrder = ['education', 'role', 'project', 'skill', 'goal', 'interest'];
    const ySpacing = height / typeOrder.length;
    
    typeOrder.forEach((type, typeIndex) => {
      const typeNodes = nodesByType[type] || [];
      const xSpacing = width / (typeNodes.length + 1);
      
      typeNodes.forEach((node, index) => {
        node.position = {
          x: xSpacing * (index + 1),
          y: ySpacing * typeIndex + 50
        };
      });
    });
    
    return nodes;
  }
}