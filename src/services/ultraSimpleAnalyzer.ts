import { ProcessedDocument } from './documentProcessor';

export interface ExtractedNode {
  id: string;
  label: string;
  type: 'role' | 'project' | 'education' | 'goal' | 'interest' | 'skill';
  timeframe?: {
    start?: string;
    end?: string;
  };
  sourceDocuments: string[];
  connections: string[];
  position: { x: number; y: number };
  metadata: {
    confidence: number;
    autoGenerated: boolean;
    extractedText?: string;
    context?: string;
  };
}

export interface AnalysisResult {
  nodes: ExtractedNode[];
  timeline: {
    startDate: string;
    endDate: string;
    events: Array<{
      date: string;
      nodeId: string;
      description: string;
    }>;
  };
}

export class UltraSimpleAnalyzer {
  async analyzeDocuments(documents: ProcessedDocument[]): Promise<AnalysisResult> {
    console.log('\n=== ULTRA SIMPLE ANALYSIS - DEBUGGING ===');
    
    const allNodes: ExtractedNode[] = [];

    for (const doc of documents) {
      console.log(`\n📄 DOCUMENT: ${doc.fileName}`);
      console.log(`📊 Content length: ${doc.content.length} characters`);
      console.log(`🔍 First 500 characters:`);
      console.log(`"${doc.content.substring(0, 500)}"`);
      console.log(`\n📝 FULL CONTENT:`);
      console.log(`"${doc.content}"`);
      
      // Skip failed processing
      if (doc.content.includes('[PDF file:') || doc.content.includes('Could not extract')) {
        console.log('❌ Skipping failed document');
        continue;
      }
      
      // Split into lines for analysis
      const lines = doc.content.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);
      
      console.log(`\n📋 Processing ${lines.length} lines:`);
      lines.forEach((line, i) => {
        console.log(`${i + 1}: "${line}"`);
      });
      
      // Try to extract ONLY the most obvious things
      const nodes = this.extractObviousContent(lines, doc.fileName);
      console.log(`\n✅ Extracted ${nodes.length} nodes from ${doc.fileName}`);
      
      nodes.forEach(node => {
        console.log(`   - ${node.type}: "${node.label}" (from: "${node.metadata.extractedText}")`);
      });
      
      allNodes.push(...nodes);
    }

    console.log(`\n🎯 FINAL RESULT: ${allNodes.length} total nodes`);
    allNodes.forEach(node => {
      console.log(`   ${node.type}: "${node.label}"`);
    });

    // Position nodes
    const positionedNodes = this.positionNodes(allNodes);

    // Create minimal timeline
    const events = allNodes
      .filter(node => node.timeframe?.start)
      .map(node => ({
        date: node.timeframe!.start!,
        nodeId: node.id,
        description: node.label
      }))
      .sort((a, b) => a.date.localeCompare(b.date));

    const result = {
      nodes: positionedNodes,
      timeline: {
        startDate: events.length > 0 ? events[0].date : new Date().toISOString(),
        endDate: events.length > 0 ? events[events.length - 1].date : new Date().toISOString(),
        events
      }
    };

    console.log('\n=== ANALYSIS COMPLETE ===');
    return result;
  }

  private extractObviousContent(lines: string[], fileName: string): ExtractedNode[] {
    const nodes: ExtractedNode[] = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
      
      console.log(`\n🔍 Analyzing line ${i + 1}: "${line}"`);
      
      // VERY conservative job title extraction
      const jobNode = this.tryExtractJob(line, nextLine, fileName);
      if (jobNode) {
        console.log(`   ✅ Found job: "${jobNode.label}"`);
        nodes.push(jobNode);
        continue;
      }
      
      // VERY conservative education extraction
      const eduNode = this.tryExtractEducation(line, fileName);
      if (eduNode) {
        console.log(`   ✅ Found education: "${eduNode.label}"`);
        nodes.push(eduNode);
        continue;
      }
      
      console.log(`   ❌ No match found`);
    }
    
    return nodes;
  }

  private tryExtractJob(line: string, nextLine: string, fileName: string): ExtractedNode | null {
    // Handle common LinkedIn format patterns
    
    // Pattern 1: "Job Title at Company Name" (most common)
    const atPattern = /^(.+?)\s+at\s+(.+?)(?:\s*\(|\s*$|•|·)/i;
    const atMatch = line.match(atPattern);
    if (atMatch) {
      const title = atMatch[1].trim();
      const company = atMatch[2].trim();
      
      if (this.looksLikeJobTitle(title) && this.looksLikeCompany(company)) {
        console.log(`   🎯 Found "at" pattern: "${title}" at "${company}"`);
        const dates = this.extractDates(line + ' ' + nextLine);
        
        return {
          id: `job_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          label: `${title} at ${company}`,
          type: 'role',
          timeframe: dates,
          sourceDocuments: [fileName],
          connections: [],
          position: { x: 0, y: 0 },
          metadata: {
            confidence: 0.9,
            autoGenerated: true,
            extractedText: line,
            context: 'title_at_company'
          }
        };
      }
    }
    
    // Pattern 2: "Job Title | Company Name" 
    const pipePattern = /^(.+?)\s*\|\s*(.+?)(?:\s*\(|\s*$|•|·)/i;
    const pipeMatch = line.match(pipePattern);
    if (pipeMatch) {
      const title = pipeMatch[1].trim();
      const company = pipeMatch[2].trim();
      
      if (this.looksLikeJobTitle(title) && this.looksLikeCompany(company)) {
        console.log(`   🎯 Found pipe pattern: "${title}" | "${company}"`);
        const dates = this.extractDates(line + ' ' + nextLine);
        
        return {
          id: `job_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          label: `${title} at ${company}`,
          type: 'role',
          timeframe: dates,
          sourceDocuments: [fileName],
          connections: [],
          position: { x: 0, y: 0 },
          metadata: {
            confidence: 0.9,
            autoGenerated: true,
            extractedText: line,
            context: 'title_pipe_company'
          }
        };
      }
    }
    
    // Pattern 3: "Job Title, Company Name"
    const commaPattern = /^(.+?),\s+(.+?)(?:\s*\(|\s*$|•|·)/i;
    const commaMatch = line.match(commaPattern);
    if (commaMatch) {
      const title = commaMatch[1].trim();
      const company = commaMatch[2].trim();
      
      if (this.looksLikeJobTitle(title) && this.looksLikeCompany(company)) {
        console.log(`   🎯 Found comma pattern: "${title}", "${company}"`);
        const dates = this.extractDates(line + ' ' + nextLine);
        
        return {
          id: `job_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          label: `${title} at ${company}`,
          type: 'role',
          timeframe: dates,
          sourceDocuments: [fileName],
          connections: [],
          position: { x: 0, y: 0 },
          metadata: {
            confidence: 0.9,
            autoGenerated: true,
            extractedText: line,
            context: 'title_comma_company'
          }
        };
      }
    }
    
    // Pattern 4: Just a job title line (followed by company on next line)
    if (this.looksLikeJobTitle(line.trim()) && this.looksLikeCompany(nextLine.trim())) {
      console.log(`   🎯 Found title+company lines: "${line}" + "${nextLine}"`);
      const dates = this.extractDates(nextLine);
      
      return {
        id: `job_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: `${line.trim()} at ${nextLine.trim()}`,
        type: 'role',
        timeframe: dates,
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.8,
          autoGenerated: true,
          extractedText: line + ' | ' + nextLine,
          context: 'separate_lines'
        }
      };
    }
    
    return null;
  }

  private tryExtractEducation(line: string, fileName: string): ExtractedNode | null {
    // Handle common LinkedIn education patterns
    
    // Pattern 1: "Degree at University" 
    const atPattern = /^(.+?)\s+at\s+(.+?)(?:\s*\(|\s*$|•|·)/i;
    const atMatch = line.match(atPattern);
    if (atMatch) {
      const degree = atMatch[1].trim();
      const school = atMatch[2].trim();
      
      if (this.looksLikeEducation(degree + ' ' + school)) {
        console.log(`   🎯 Found education "at" pattern: "${degree}" at "${school}"`);
        const dates = this.extractDates(line);
        
        return {
          id: `edu_${Date.now()}_${Math.random().toString(36).substring(7)}`,
          label: `${degree} at ${school}`,
          type: 'education',
          timeframe: dates,
          sourceDocuments: [fileName],
          connections: [],
          position: { x: 0, y: 0 },
          metadata: {
            confidence: 0.9,
            autoGenerated: true,
            extractedText: line,
            context: 'degree_at_school'
          }
        };
      }
    }
    
    // Pattern 2: "University Name" (school names often contain these words)
    const schoolWords = ['university', 'college', 'institute', 'school', 'academy'];
    if (schoolWords.some(word => line.toLowerCase().includes(word)) && line.length > 10) {
      console.log(`   🎯 Found education institution: "${line}"`);
      
      const dates = this.extractDates(line);
      
      return {
        id: `edu_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: line.trim(),
        type: 'education',
        timeframe: dates,
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.8,
          autoGenerated: true,
          extractedText: line,
          context: 'school_name'
        }
      };
    }
    
    // Pattern 3: Degree descriptions
    const degreeWords = ['bachelor', 'master', 'mba', 'phd', 'degree', 'diploma', 'certificate'];
    if (degreeWords.some(word => line.toLowerCase().includes(word)) && line.length > 10) {
      console.log(`   🎯 Found degree description: "${line}"`);
      
      const dates = this.extractDates(line);
      
      return {
        id: `degree_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: line.trim(),
        type: 'education',
        timeframe: dates,
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.8,
          autoGenerated: true,
          extractedText: line,
          context: 'degree'
        }
      };
    }
    
    return null;
  }

  private extractDates(text: string): { start?: string; end?: string } | undefined {
    console.log(`   📅 Looking for dates in: "${text}"`);
    
    const patterns = [
      /\((\d{4})\s*[-–]\s*(\d{4})\)/,  // (2020-2023)
      /(\d{4})\s*[-–]\s*(\d{4})/,      // 2020-2023
      /(\d{4})\s*[-–]\s*(Present|Current)/i,  // 2020-Present
      /\((\d{4})\s*[-–]\s*(Present|Current)\)/i  // (2020-Present)
    ];
    
    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        console.log(`   ✅ Date match: "${match[0]}"`);
        
        if (match[2].toLowerCase().includes('present') || match[2].toLowerCase().includes('current')) {
          return { start: `${match[1]}-01` };
        } else {
          return { start: `${match[1]}-01`, end: `${match[2]}-12` };
        }
      }
    }
    
    console.log(`   ❌ No dates found`);
    return undefined;
  }

  private looksLikeJobTitle(title: string): boolean {
    const jobWords = [
      'engineer', 'developer', 'manager', 'analyst', 'consultant', 'director',
      'specialist', 'coordinator', 'lead', 'senior', 'junior', 'associate',
      'product', 'software', 'data', 'marketing', 'sales', 'finance', 'business',
      'project', 'program', 'operations', 'strategy', 'research', 'design',
      'intern', 'trainee', 'assistant', 'executive', 'officer', 'head',
      'founder', 'ceo', 'cto', 'cfo', 'vp', 'vice president', 'principal',
      'architect', 'scientist', 'researcher', 'writer', 'editor', 'creator'
    ];
    
    const lower = title.toLowerCase();
    const hasJobWord = jobWords.some(word => lower.includes(word));
    const validLength = title.length > 3 && title.length < 80;
    const notEmail = !lower.includes('@');
    const notUrl = !lower.includes('http');
    
    const isValid = hasJobWord && validLength && notEmail && notUrl;
    
    console.log(`   🔍 Job title validation "${title}": ${isValid}`);
    return isValid;
  }

  private looksLikeCompany(company: string): boolean {
    const isValid = company.length > 1 && 
                   company.length < 80 && 
                   !company.includes('@') &&
                   !company.includes('http') &&
                   company.toLowerCase() !== 'present' &&
                   company.toLowerCase() !== 'current' &&
                   !company.match(/^\d{4}$/); // Not just a year
    
    console.log(`   🔍 Company validation "${company}": ${isValid}`);
    return isValid;
  }

  private looksLikeEducation(education: string): boolean {
    const eduWords = ['university', 'college', 'institute', 'school', 'academy', 'master', 'bachelor', 'phd', 'mba', 'degree', 'diploma', 'certificate'];
    const lower = education.toLowerCase();
    const isValid = eduWords.some(word => lower.includes(word)) && education.length > 5;
    
    console.log(`   🔍 Education validation "${education}": ${isValid}`);
    return isValid;
  }

  private positionNodes(nodes: ExtractedNode[]): ExtractedNode[] {
    const width = 800;
    
    // Group by type
    const types = ['education', 'role', 'project', 'skill', 'goal'];
    const byType = nodes.reduce((acc, node) => {
      if (!acc[node.type]) acc[node.type] = [];
      acc[node.type].push(node);
      return acc;
    }, {} as Record<string, ExtractedNode[]>);
    
    let currentY = 100;
    for (const type of types) {
      const typeNodes = byType[type] || [];
      if (typeNodes.length === 0) continue;
      
      const xSpacing = width / (typeNodes.length + 1);
      const rowY = currentY;
      typeNodes.forEach((node, i) => {
        node.position = { x: xSpacing * (i + 1), y: rowY };
      });
      
      currentY += 100;
    }
    
    return nodes;
  }
}