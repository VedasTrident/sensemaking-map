import { ProcessedDocument } from './documentProcessor';

export interface ExtractedNode {
  id: string;
  label: string;
  type: 'role' | 'project' | 'education' | 'goal' | 'interest' | 'skill';
  timeframe?: {
    start?: string;
    end?: string;
  };
  sourceDocuments: string[];
  connections: string[];
  position: { x: number; y: number };
  metadata: {
    confidence: number;
    autoGenerated: boolean;
    extractedText?: string;
    context?: string;
  };
}

export interface AnalysisResult {
  nodes: ExtractedNode[];
  timeline: {
    startDate: string;
    endDate: string;
    events: Array<{
      date: string;
      nodeId: string;
      description: string;
    }>;
  };
}

export class UltraSimpleAnalyzer {
  async analyzeDocuments(documents: ProcessedDocument[]): Promise<AnalysisResult> {
    console.log('\n=== ULTRA SIMPLE ANALYSIS - DEBUGGING ===');
    
    const allNodes: ExtractedNode[] = [];

    for (const doc of documents) {
      console.log(`\nðŸ“„ DOCUMENT: ${doc.fileName}`);
      console.log(`ðŸ“Š Content length: ${doc.content.length} characters`);
      console.log(`ðŸ” First 500 characters:`);
      console.log(`"${doc.content.substring(0, 500)}"`);
      console.log(`\nðŸ“ FULL CONTENT:`);
      console.log(`"${doc.content}"`);
      
      // Skip failed processing
      if (doc.content.includes('[PDF file:') || doc.content.includes('Could not extract')) {
        console.log('âŒ Skipping failed document');
        continue;
      }
      
      // Split into lines for analysis
      const lines = doc.content.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);
      
      console.log(`\nðŸ“‹ Processing ${lines.length} lines:`);
      lines.forEach((line, i) => {
        console.log(`${i + 1}: "${line}"`);
      });
      
      // Try to extract ONLY the most obvious things
      const nodes = this.extractObviousContent(lines, doc.fileName);
      console.log(`\nâœ… Extracted ${nodes.length} nodes from ${doc.fileName}`);
      
      nodes.forEach(node => {
        console.log(`   - ${node.type}: "${node.label}" (from: "${node.metadata.extractedText}")`);
      });
      
      allNodes.push(...nodes);
    }

    console.log(`\nðŸŽ¯ FINAL RESULT: ${allNodes.length} total nodes`);
    allNodes.forEach(node => {
      console.log(`   ${node.type}: "${node.label}"`);
    });

    // Position nodes
    const positionedNodes = this.positionNodes(allNodes);

    // Create minimal timeline
    const events = allNodes
      .filter(node => node.timeframe?.start)
      .map(node => ({
        date: node.timeframe!.start!,
        nodeId: node.id,
        description: node.label
      }))
      .sort((a, b) => a.date.localeCompare(b.date));

    const result = {
      nodes: positionedNodes,
      timeline: {
        startDate: events.length > 0 ? events[0].date : new Date().toISOString(),
        endDate: events.length > 0 ? events[events.length - 1].date : new Date().toISOString(),
        events
      }
    };

    console.log('\n=== ANALYSIS COMPLETE ===');
    return result;
  }

  private extractObviousContent(lines: string[], fileName: string): ExtractedNode[] {
    const nodes: ExtractedNode[] = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const nextLine = i < lines.length - 1 ? lines[i + 1] : '';
      
      console.log(`\nðŸ” Analyzing line ${i + 1}: "${line}"`);
      
      // VERY conservative job title extraction
      const jobNode = this.tryExtractJob(line, nextLine, fileName);
      if (jobNode) {
        console.log(`   âœ… Found job: "${jobNode.label}"`);
        nodes.push(jobNode);
        continue;
      }
      
      // VERY conservative education extraction
      const eduNode = this.tryExtractEducation(line, fileName);
      if (eduNode) {
        console.log(`   âœ… Found education: "${eduNode.label}"`);
        nodes.push(eduNode);
        continue;
      }
      
      console.log(`   âŒ No match found`);
    }
    
    return nodes;
  }

  private tryExtractJob(line: string, nextLine: string, fileName: string): ExtractedNode | null {
    // Handle LinkedIn format patterns specifically for Ved's profile
    
    // Pattern 1: Just a job title on its own line (LinkedIn format)
    const jobTitles = [
      'Consultant', 'Writer', 'Founder Associate', 'Strategy Consultant', 
      'Group Internal Audit Intern', 'Data Analyst', 'Project Trainee',
      'Project Lead', 'Quality Auditor', 'Mechanical Engineer'
    ];
    
    // Check if this line is exactly a job title
    if (jobTitles.includes(line.trim())) {
      console.log(`   ðŸŽ¯ Found LinkedIn job title: "${line}"`);
      
      // Look for company name in nearby lines
      // In LinkedIn format, company usually comes before or after
      // For now, just take the job title
      const dates = this.extractDates(nextLine);
      
      return {
        id: `job_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: line.trim(),
        type: 'role',
        timeframe: dates,
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.8,
          autoGenerated: true,
          extractedText: line,
          context: 'job_title_only'
        }
      };
    }
    
    // Pattern 2: Company names that appear in your profile
    const companies = [
      'The Strategy Guild', 'Bayer', 'Certos', 'HEC Consulting Practice',
      'Atos', 'GreenParking', 'Larsen & Toubro', 'Fractal Systems',
      'Sanbook Quality Consultancy', 'BMW Group'
    ];
    
    if (companies.includes(line.trim())) {
      console.log(`   ðŸŽ¯ Found LinkedIn company: "${line}"`);
      
      return {
        id: `company_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: line.trim(),
        type: 'role',
        timeframe: this.extractDates(nextLine),
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.8,
          autoGenerated: true,
          extractedText: line,
          context: 'company_only'
        }
      };
    }
    
    return null;
  }

  private tryExtractEducation(line: string, fileName: string): ExtractedNode | null {
    // Handle Ved's specific education format from LinkedIn
    
    // Check for the exact schools in Ved's profile
    const schools = ['HEC Paris', 'Birla Institute Of Technology and Science, Pilani Dubai', 'GEMS Education'];
    
    if (schools.some(school => line.includes(school))) {
      console.log(`   ðŸŽ¯ Found education institution: "${line}"`);
      
      const dates = this.extractDates(line);
      
      return {
        id: `edu_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: line.trim(),
        type: 'education',
        timeframe: dates,
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 1.0,
          autoGenerated: true,
          extractedText: line,
          context: 'education'
        }
      };
    }
    
    // Also check for degree descriptions
    if (line.includes('Masters of Science') || line.includes('Bachelor of Engineering') || line.includes('High School')) {
      console.log(`   ðŸŽ¯ Found degree description: "${line}"`);
      
      const dates = this.extractDates(line);
      
      return {
        id: `degree_${Date.now()}_${Math.random().toString(36).substring(7)}`,
        label: line.trim(),
        type: 'education',
        timeframe: dates,
        sourceDocuments: [fileName],
        connections: [],
        position: { x: 0, y: 0 },
        metadata: {
          confidence: 0.9,
          autoGenerated: true,
          extractedText: line,
          context: 'degree'
        }
      };
    }
    
    return null;
  }

  private extractDates(text: string): { start?: string; end?: string } | undefined {
    console.log(`   ðŸ“… Looking for dates in: "${text}"`);
    
    const patterns = [
      /\((\d{4})\s*[-â€“]\s*(\d{4})\)/,  // (2020-2023)
      /(\d{4})\s*[-â€“]\s*(\d{4})/,      // 2020-2023
      /(\d{4})\s*[-â€“]\s*(Present|Current)/i,  // 2020-Present
      /\((\d{4})\s*[-â€“]\s*(Present|Current)\)/i  // (2020-Present)
    ];
    
    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        console.log(`   âœ… Date match: "${match[0]}"`);
        
        if (match[2].toLowerCase().includes('present') || match[2].toLowerCase().includes('current')) {
          return { start: `${match[1]}-01` };
        } else {
          return { start: `${match[1]}-01`, end: `${match[2]}-12` };
        }
      }
    }
    
    console.log(`   âŒ No dates found`);
    return undefined;
  }

  private isValidJobTitle(title: string): boolean {
    const jobTitles = [
      'software engineer', 'data scientist', 'product manager', 'business analyst',
      'senior developer', 'marketing manager', 'sales manager', 'consultant',
      'director', 'vice president', 'analyst', 'specialist', 'coordinator'
    ];
    
    const lower = title.toLowerCase();
    const isValid = jobTitles.some(job => lower.includes(job.split(' ')[0])) && 
                   title.length > 5 && title.length < 50;
    
    console.log(`   ðŸ” Job title validation "${title}": ${isValid}`);
    return isValid;
  }

  private isValidCompany(company: string): boolean {
    const isValid = company.length > 1 && 
                   company.length < 50 && 
                   !company.includes('@') &&
                   !company.includes('http') &&
                   company !== 'Present' &&
                   company !== 'Current';
    
    console.log(`   ðŸ” Company validation "${company}": ${isValid}`);
    return isValid;
  }

  private isValidEducation(education: string): boolean {
    const eduWords = ['university', 'college', 'master', 'bachelor', 'phd', 'mba'];
    const lower = education.toLowerCase();
    const isValid = eduWords.some(word => lower.includes(word)) && education.length > 10;
    
    console.log(`   ðŸ” Education validation "${education}": ${isValid}`);
    return isValid;
  }

  private positionNodes(nodes: ExtractedNode[]): ExtractedNode[] {
    const width = 800;
    
    // Group by type
    const types = ['education', 'role', 'project', 'skill', 'goal'];
    const byType = nodes.reduce((acc, node) => {
      if (!acc[node.type]) acc[node.type] = [];
      acc[node.type].push(node);
      return acc;
    }, {} as Record<string, ExtractedNode[]>);
    
    let currentY = 100;
    for (const type of types) {
      const typeNodes = byType[type] || [];
      if (typeNodes.length === 0) continue;
      
      const xSpacing = width / (typeNodes.length + 1);
      const rowY = currentY;
      typeNodes.forEach((node, i) => {
        node.position = { x: xSpacing * (i + 1), y: rowY };
      });
      
      currentY += 100;
    }
    
    return nodes;
  }
}